// Generated by CoffeeScript 1.4.0
var REST, derbyAuth, groupSystem, publicAccess, userAccess;

derbyAuth = require('derby-auth/store');

/*
Setup read / write access
@param store
*/


publicAccess = function() {
  var accept;
  accept = arguments[arguments.length - 2];
  if (derbyAuth.bustedSession(this)) {
    return accept(false);
  }
  return accept(true);
};

module.exports.customAccessControl = function(store) {
  userAccess(store);
  groupSystem(store);
  return REST(store);
};

/*
  General user access
*/


userAccess = function(store) {
  store.readPathAccess("users.*", function() {
    var accept, err, uid;
    accept = arguments[arguments.length - 2];
    err = arguments[arguments.length - 1];
    if (derbyAuth.bustedSession(this)) {
      return accept(false);
    }
    accept = arguments[arguments.length - 2];
    uid = arguments[0];
    return accept((uid === this.session.userId) || derbyAuth.isServer(this));
  });
  store.writeAccess("*", "users.*", function() {
    var accept, attrPath, captures, err, uid;
    accept = arguments[arguments.length - 2];
    err = arguments[arguments.length - 1];
    if (derbyAuth.isServer(this)) {
      return accept(true);
    }
    if (derbyAuth.bustedSession(this)) {
      return accept(false);
    }
    captures = arguments[0].split('.');
    uid = captures.shift();
    attrPath = captures.join('.');
    if (attrPath === 'backer') {
      return accept(false);
    }
    if (attrPath.indexOf('invitations.') === 0) {
      return accept(true);
    }
    if (uid === this.session.userId) {
      return accept(true);
    }
    return accept(false);
  });
  store.writeAccess("*", "users.*.balance", function(id, newBalance, accept, err) {
    var oldBalance, purchasingSomethingOnClient, _ref, _ref1;
    if (derbyAuth.bustedSession(this)) {
      return accept(false);
    }
    oldBalance = ((_ref = this.session.req) != null ? (_ref1 = _ref._racerModel) != null ? _ref1.get("users." + id + ".balance") : void 0 : void 0) || 0;
    purchasingSomethingOnClient = newBalance < oldBalance;
    return accept(purchasingSomethingOnClient || derbyAuth.isServer(this));
  });
  return store.writeAccess("*", "users.*.flags.ads", function() {
    var accept, err;
    accept = arguments[arguments.length - 2];
    err = arguments[arguments.length - 1];
    if (derbyAuth.bustedSession(this)) {
      return accept(false);
    }
    return accept(derbyAuth.isServer(this));
  });
};

/*
  REST
  Get user with API token
*/


REST = function(store) {
  store.query.expose("users", "withIdAndToken", function(uid, token) {
    return this.where("id").equals(uid).where('apiToken').equals(token).findOne();
  });
  return store.queryAccess("users", "withIdAndToken", function(uid, token, accept, err) {
    if (uid && token) {
      return accept(true);
    }
    return accept(false);
  });
};

/*
  Party & Guild Permissions
*/


groupSystem = function(store) {
  /*
      Public User Info
  */
  store.query.expose("users", "publicInfo", function(ids) {
    return this.where("id").within(ids).only('stats', 'items', 'invitations', 'profile', 'achievements', 'backer', 'preferences', 'auth.local.username', 'auth.facebook.displayName');
  });
  store.queryAccess("users", "publicInfo", publicAccess);
  /*
      Read / Write groups, so they can create new groups
  */

  store.readPathAccess("groups.*", publicAccess);
  store.writeAccess("*", "groups.*", publicAccess);
  /*
      Public HabitRPG Guild
  */

  store.readPathAccess('groups.habitrpg', publicAccess);
  store.writeAccess("*", "groups.habitrpg.chat.*", publicAccess);
  store.writeAccess("*", "groups.habitrpg.challenges.*", publicAccess);
  /*
      Find group which has member by id
  */

  store.query.expose("groups", "withMember", function(id, type) {
    var q;
    q = this.where('members').contains([id]).only(['id', 'type', 'name', 'description', 'members', 'privacy']);
    if (type != null) {
      return q = q.where('type').equals(type);
    }
  });
  store.queryAccess('groups', 'withMember', publicAccess);
  /*
      Public Groups Info
  */

  store.query.expose("groups", "publicGroups", function() {
    return this.where('privacy').equals('public').where('type').equals('guild').only(['id', 'type', 'name', 'description', 'members', 'privacy']);
  });
  store.queryAccess("groups", "publicGroups", publicAccess);
  /*
      Fetch group info (ie, they just got invited)
  */

  store.query.expose("groups", "withIds", function(ids) {
    if (!ids) {
      return;
    }
    if (typeof ids === 'string') {
      return this.where("id").equals(ids).findOne();
    } else {
      return this.where("id").within(ids);
    }
  });
  return store.queryAccess("groups", "withIds", publicAccess);
};
